import threading
import time
import base64
import os
import tempfile
import csv
import ctypes
import json
from datetime import datetime

from tkinter import Tk, Canvas, StringVar, BooleanVar, IntVar, filedialog, LEFT, RIGHT, Text, X, Y, Spinbox, END
from tkinter.ttk import Frame, LabelFrame, Label, Combobox, Checkbutton, Button, Scrollbar, Style, Entry
from pynput.mouse import Listener as MouseListener
import keyboard
import pygetwindow as gw
import pyautogui
import win32gui
import win32con
import win32api
import win32process

class AutoKeyBroadcaster:
    def __init__(self, root):
        self.root = root
        self.root.title("NickBox - Input Broadcaster")
        self.icon_base64 = "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"
        self.icon_path = None
        self.root.withdraw()
        self.create_icon_in_background()
        self.root.geometry("500x950")
        self.root.resizable(False, False)
        self.target_window_pattern = StringVar()
        self.is_broadcasting = False
        self.is_auto_focusing = False
        self.is_auto_focusing_paused = False
        self.broadcast_thread = None
        self.hide_taskbar_var = BooleanVar(value=False)
        self.taskbar_hidden = False
        self.focus_thread = None
        self.grid_snap_enabled = BooleanVar(value=True)
        self.grid_snap_size = IntVar(value=20)
        self.window_snap_enabled = BooleanVar(value=True)
        self.corner_snap_enabled = BooleanVar(value=True)
        self.running = True
        self.broadcast_all_keys = BooleanVar(value=False)
        self.logging_enabled = BooleanVar(value=True)
        self.WM_KEYDOWN = 0x0100
        self.WM_KEYUP = 0x0101
        self.current_profile = "default"
        self.profiles_dir = "settings"
        self.profile_config_file = os.path.join(self.profiles_dir, "profile_config.json")
        self.keys_file = os.path.join(self.profiles_dir, "keys.csv")
        self.log_file = "log.txt"
        if not os.path.exists(self.profiles_dir):
            os.makedirs(self.profiles_dir)
        self.load_profile_config()
        self.load_keys()
        self.window_list = self.get_all_windows()
        self.window_rects = {}
        self.dragging_window = None
        self.resizing_window = None
        self.screen_scale = 0.1
        self.create_widgets()
        self.apply_profile_settings()
        self.root.update_idletasks()    
        self.root.after(500, self.update_window_visualization)
        self.alt_tab_pressed = False
        self.alt_tab_pause_time = 1
        self.last_alt_tab_release_time = 0
        self.alt_tab_pressed = False
        self.keyboard_listener()
        self.mouse_listener = MouseListener(on_click=self.on_mouse_click)
        self.mouse_listener.start()

    def create_icon_in_background(self):
        # Start a background thread to handle icon creation
        def _create_icon():
            try:
                icon_data = base64.b64decode(self.icon_base64)
                temp_dir = tempfile.gettempdir()
                self.icon_path = os.path.join(temp_dir, "nickbox_temp.ico")
                
                # Write the icon data to a temporary file without showing the process to the user
                with open(self.icon_path, "wb") as icon_file:
                    icon_file.write(icon_data)

                # Set the icon after it's been created
                self.root.after(0, self.set_window_icon)
            except Exception as e:
                print(f"Could not set the app icon: {e}")
        
        # Run the icon creation process in a separate thread
        icon_thread = threading.Thread(target=_create_icon)
        icon_thread.daemon = True  # Allow the thread to exit when the main program exits
        icon_thread.start()

    def set_window_icon(self):
        if self.icon_path and os.path.exists(self.icon_path):
            self.root.iconbitmap(self.icon_path)
            self.root.deiconify()
        
    def toggle_taskbar(self, hide=True):
        try:
            # Get the taskbar window handle
            taskbar_hwnd = win32gui.FindWindow("Shell_TrayWnd", None)
            if not taskbar_hwnd:
                self.log("Couldn't find taskbar window")
                return
                
            if hide and not self.taskbar_hidden:
                self.log("Hiding taskbar")
                # Hide the taskbar using ShowWindow API
                win32gui.ShowWindow(taskbar_hwnd, win32con.SW_HIDE)
                self.taskbar_hidden = True
            elif not hide and self.taskbar_hidden:
                self.log("Showing taskbar")
                # Show the taskbar
                win32gui.ShowWindow(taskbar_hwnd, win32con.SW_SHOW)
                self.taskbar_hidden = False
                
            # Also handle the secondary taskbar that may appear on other monitors
            secondary_taskbar = win32gui.FindWindow("Shell_SecondaryTrayWnd", None)
            if secondary_taskbar:
                win32gui.ShowWindow(secondary_taskbar, win32con.SW_HIDE if hide else win32con.SW_SHOW)
                
        except Exception as e:
            self.log(f"Error toggling taskbar: {str(e)}")
        
    def keyboard_listener(self):
        # Bind the Alt key press and release events
        keyboard.on_press_key('alt', self.on_alt_press)
        keyboard.on_release_key('alt', self.on_alt_release)
        keyboard.on_press_key('tab', self.on_tab_press)

    def on_alt_press(self, event):
        if self.is_auto_focusing and not self.is_auto_focusing_paused:
            if self.pause_alt_tab_var.get():
                if keyboard.is_pressed('alt') and keyboard.is_pressed('tab'):
                    self.alt_tab_pressed = True
                    self.last_alt_tab_release_time = time.time()
                    self.log("Alt+Tab detected, pausing auto focus")
                    self.is_auto_focusing_paused = True

    def on_tab_press(self, event):
        if self.is_auto_focusing and not self.is_auto_focusing_paused:
            if self.pause_alt_tab_var.get():
                if keyboard.is_pressed('alt') and keyboard.is_pressed('tab'):
                    self.alt_tab_pressed = True
                    self.last_alt_tab_release_time = time.time()
                    self.log("Alt+Tab detected, pausing auto focus")
                    self.is_auto_focusing_paused = True

    def on_alt_release(self, event):
        if self.pause_alt_tab_var.get():
            if not keyboard.is_pressed('alt') and self.alt_tab_pressed:
                self.alt_tab_pressed = False
                self.log("Alt key released, resuming auto focus")
                self.is_auto_focusing_paused = False

    def on_mouse_click(self, x, y, button, pressed):
        if button.name == 'right':
            if pressed:
                self.log("Right mouse button pressed, pausing auto focus")
                self.is_auto_focusing_paused = True
            else:
                self.log("Right mouse button released, resuming auto focus")
                self.is_auto_focusing_paused = False

    def load_profile_config(self):
        if os.path.exists(self.profile_config_file):
            try:
                with open(self.profile_config_file, 'r') as f:
                    config = json.load(f)
                    self.current_profile = config.get("default_profile", "default")
            except:
                self.current_profile = "default"
        else:
            with open(self.profile_config_file, 'w') as f:
                json.dump({"default_profile": "default"}, f)

    def save_profile_config(self, default_profile=None):
        if default_profile:
            self.current_profile = default_profile
        with open(self.profile_config_file, 'w') as f:
            json.dump({"default_profile": self.current_profile}, f)

    def get_profile_settings_file(self, profile_name="default"):
        if profile_name == "default":
            return os.path.join(self.profiles_dir, "profile_settings.json")
        else:
            return os.path.join(self.profiles_dir, f"profile{profile_name}_settings.json")

    def get_profile_keys_file(self, profile_name="default"):
        if profile_name == "default":
            return os.path.join(self.profiles_dir, "keys.csv")
        else:
            return os.path.join(self.profiles_dir, f"profile{profile_name}.txt")

    def save_profile_settings(self):
        settings_file = self.get_profile_settings_file(self.current_profile)
        settings = {
            "window_pattern": self.target_window_pattern.get(),
            "broadcast_all_keys": self.broadcast_all_keys.get(),
            "is_broadcasting": self.is_broadcasting,
            "is_auto_focusing": self.is_auto_focusing,
            "logging_enabled": self.logging_enabled.get(),
            "hide_taskbar": self.hide_taskbar_var.get(),
            "grid_snap_enabled": self.grid_snap_enabled.get(),
            "grid_snap_size": self.grid_snap_size.get(),
            "window_snap_enabled": self.window_snap_enabled.get(),
            "corner_snap_enabled": self.corner_snap_enabled.get()
        }
        with open(settings_file, 'w') as f:
            json.dump(settings, f)

    def load_profile_settings(self):
        settings_file = self.get_profile_settings_file(self.current_profile)
        if os.path.exists(settings_file):
            try:
                with open(settings_file, 'r') as f:
                    settings = json.load(f)
                    if settings.get("window_pattern"):
                        self.target_window_pattern.set(settings.get("window_pattern"))
                    self.broadcast_all_keys.set(settings.get("broadcast_all_keys", False))
                    self.is_broadcasting = settings.get("is_broadcasting", False)
                    self.is_auto_focusing = settings.get("is_auto_focusing", False)
                    self.logging_enabled.set(settings.get("logging_enabled", True))
                    self.hide_taskbar_var.set(settings.get("hide_taskbar", False))
                    self.grid_snap_enabled.set(settings.get("grid_snap_enabled", True))
                    self.grid_snap_size.set(settings.get("grid_snap_size", 20))
                    self.window_snap_enabled.set(settings.get("window_snap_enabled", True))
                    self.corner_snap_enabled.set(settings.get("corner_snap_enabled", True))

                    return True
            except:
                return False
        return False

    def apply_profile_settings(self):
        if self.load_profile_settings():
            if self.target_window_pattern.get() and self.target_window_pattern.get() in self.window_list:
                self.window_combo.set(self.target_window_pattern.get())
            else:
                self.target_window_pattern.set("")
            self.toggle_broadcast_mode()
            if self.is_broadcasting:
                self.broadcast_btn.config(text="Stop Broadcasting")
                self.broadcast_thread = threading.Thread(target=self.broadcast_keys)
                self.broadcast_thread.daemon = True
                self.broadcast_thread.start()
            if self.is_auto_focusing:
                self.focus_btn.config(text="Disable Auto Focus")
                self.focus_thread = threading.Thread(target=self.auto_focus)
                self.focus_thread.daemon = True
                self.focus_thread.start()
            if not self.logging_enabled.get():
                self.logging_checkbox.invoke()

    def load_keys(self):
        keys_file = self.get_profile_keys_file(self.current_profile)
        if not os.path.exists(keys_file):
            if not os.path.exists(self.profiles_dir):
                os.makedirs(self.profiles_dir)
            with open(keys_file, 'w', newline='') as file:
                writer = csv.writer(file)
                writer.writerow(['w', 'a', 's', 'd', '1', '2', '3', '4', '5', '6'])
            self.keys = "w,a,s,d,1,2,3,4,5,6"
        else:
            with open(keys_file, 'r') as file:
                reader = csv.reader(file)
                keys_list = next(reader, [])
                self.keys = ",".join(keys_list)

    def save_keys(self):
        sanitized_keys = self.sanitize_keys(self.keys_entry.get())
        self.keys_entry.delete(0, END)
        self.keys_entry.insert(0, sanitized_keys)
        
        keys_list = sanitized_keys.split(',')
        keys_file = self.get_profile_keys_file(self.current_profile)
        with open(keys_file, 'w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(keys_list)
        self.log(f"Keys saved to {keys_file}")

    def load_profile(self, profile_num):
        profile_name = str(profile_num)
        profile_file = self.get_profile_keys_file(profile_name)
        if os.path.exists(profile_file) or profile_name == "default":
            was_broadcasting = self.is_broadcasting
            was_auto_focusing = self.is_auto_focusing
            if was_broadcasting:
                self.toggle_broadcasting()
            if was_auto_focusing:
                self.toggle_auto_focus()
            self.current_profile = profile_name
            self.profile_label.config(text=f"Profile: {profile_name}")
            self.load_keys_from_file()
            self.apply_profile_settings()
            self.log(f"Loaded profile {profile_name}")
        else:
            self.log(f"Profile {profile_name} does not exist")

    def save_profile(self, profile_num):
        profile_name = str(profile_num)
        self.current_profile = profile_name
        self.save_keys()
        self.save_profile_settings()
        self.profile_label.config(text=f"Profile: {profile_name}")
        self.log(f"Saved as profile {profile_name}")

    def set_default_profile(self, profile_num):
        profile_name = str(profile_num)
        profile_file = self.get_profile_keys_file(profile_name)
        if os.path.exists(profile_file) or profile_name == "default":
            self.save_profile_config(profile_name)
            self.log(f"Set profile {profile_name} as default")
        else:
            self.log(f"Profile {profile_name} does not exist")

    def get_all_windows(self):
        all_windows = []
        for window in gw.getAllWindows():
            if window.title and window.title.strip():
                all_windows.append(window.title)
        return sorted(all_windows)

    def create_widgets(self):
        # Profile Frame
        profile_frame = Frame(self.root)
        profile_frame.pack(fill="x", padx=10, pady=2)

        self.profile_label = Label(profile_frame, text=f"Profile: {self.current_profile}")
        self.profile_label.pack(side=LEFT, padx=5)

        profile_buttons_frame = Frame(profile_frame)
        profile_buttons_frame.pack(side=RIGHT)

        self.profile_num = StringVar()
        profile_combo = Combobox(profile_buttons_frame, textvariable=self.profile_num, values=list(range(1, 11)), width=2)
        profile_combo.pack(side=LEFT, padx=2)

        load_profile_btn = Button(profile_buttons_frame, text="Load", width=5,
                                      command=lambda: self.load_profile(self.profile_num.get()))
        load_profile_btn.pack(side=LEFT, padx=2)

        save_profile_btn = Button(profile_buttons_frame, text="Save", width=5,
                                      command=lambda: self.save_profile(self.profile_num.get()))
        save_profile_btn.pack(side=LEFT, padx=2)

        default_profile_btn = Button(profile_buttons_frame, text="Set Default", width=10,
                                         command=lambda: self.set_default_profile(self.profile_num.get()))
        default_profile_btn.pack(side=LEFT, padx=2)

        # Select Frame
        select_frame = LabelFrame(self.root, text="Target Window")
        select_frame.pack(fill="x", expand=True, padx=10, pady=5)

        Label(select_frame, text="Select window:").pack(anchor="w", padx=5, pady=5)
        self.window_combo = Combobox(select_frame, textvariable=self.target_window_pattern, values=self.window_list)
        self.window_combo.pack(fill="x", padx=5, pady=5)
        self.window_combo.bind("<<ComboboxSelected>>", self.on_window_selected)
        self.window_combo.bind("<Button-1>", self.refresh_window_list)

        # Placeholder for Window Management Frame
        self.window_mgmt_frame = LabelFrame(self.root, text="Window Management")
        self.window_mgmt_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Schedule the dimension calculation
        self.root.after(100, self.setup_window_management_frame)

        self.viz_canvas = Canvas(self.window_mgmt_frame, bg="black")
        self.viz_canvas.pack(fill="both", expand=True, padx=5, pady=5)
        self.viz_canvas.bind("<Button-1>", self.start_window_drag)
        self.viz_canvas.bind("<B1-Motion>", self.drag_window)
        self.viz_canvas.bind("<ButtonRelease-1>", self.end_window_drag)
        self.viz_canvas.bind("<Button-3>", self.start_window_resize)
        self.viz_canvas.bind("<B3-Motion>", self.resize_window)
        self.viz_canvas.bind("<ButtonRelease-3>", self.end_window_resize)

        controls_frame = Frame(self.window_mgmt_frame)
        controls_frame.pack(fill="x", padx=5, pady=5)

        auto_layout_frame = Frame(controls_frame)
        auto_layout_frame.pack(side=LEFT, padx=5)

        Button(auto_layout_frame, text="Auto 1:1", command=lambda: self.auto_layout("1:1")).pack(side=LEFT)
        Button(auto_layout_frame, text="Auto 16:9", command=lambda: self.auto_layout("16:9")).pack(side=LEFT)
        Button(auto_layout_frame, text="Auto 21:9", command=lambda: self.auto_layout("21:9")).pack(side=LEFT)
        Button(auto_layout_frame, text="Auto Fill", command=self.auto_fill).pack(side=LEFT, padx=2)

        borderless_frame = Frame(controls_frame)
        borderless_frame.pack(side=RIGHT, padx=5)

        self.borderless_var = BooleanVar(value=False)
        Checkbutton(borderless_frame, text="Borderless",
                        variable=self.borderless_var, command=self.toggle_borderless).pack(side=RIGHT)

        # Broadcast Frame
        broadcast_frame = LabelFrame(self.root, text="Key Broadcasting")
        broadcast_frame.pack(fill="x", expand=True, padx=10, pady=5)

        broadcast_mode_frame = Frame(broadcast_frame)
        broadcast_mode_frame.pack(fill="x", padx=5, pady=5)

        self.broadcast_all = Checkbutton(broadcast_mode_frame, text="Broadcast all keyboard input",
                                             variable=self.broadcast_all_keys, command=self.toggle_broadcast_mode)
        self.broadcast_all.pack(side=LEFT, padx=5)

        self.broadcast_select_keys = BooleanVar(value=True)
        self.broadcast_select = Checkbutton(broadcast_mode_frame, text="Broadcast select keys",
                                                variable=self.broadcast_select_keys, command=self.toggle_broadcast_mode)
        self.broadcast_select.pack(side=RIGHT, padx=5)

        self.keys_section_frame = Frame(broadcast_frame)
        self.keys_section_frame.pack(fill="x", padx=5, pady=5)

        Label(self.keys_section_frame, text="Keys to broadcast (comma separated):").pack(anchor="w", padx=5, pady=5)
        self.keys_entry = Entry(self.keys_section_frame)
        self.keys_entry.pack(fill="x", padx=5, pady=5)
        self.keys_entry.insert(0, self.keys)
        
        self.keys_entry.bind("<FocusOut>", self.on_keys_entry_focus_out)

        keys_btn_frame = Frame(self.keys_section_frame)
        keys_btn_frame.pack(fill="x", padx=5, pady=5)

        self.load_btn = Button(keys_btn_frame, text="Load Keys", command=self.load_keys_from_file)
        self.load_btn.pack(side=LEFT, padx=5)

        self.save_btn = Button(keys_btn_frame, text="Save Keys", command=self.save_keys)
        self.save_btn.pack(side=RIGHT, padx=5)

        self.broadcast_btn = Button(broadcast_frame, text="Start Broadcasting", command=self.toggle_broadcasting)
        self.broadcast_btn.pack(anchor="center", padx=5, pady=5)

        # Auto Focus Frame
        focus_frame = LabelFrame(self.root, text="Auto Focus")
        focus_frame.pack(fill="x", expand=True, padx=10, pady=10)
        
        # Make the frame slightly taller to accommodate the new checkbox
        focus_frame.configure(height=80)  # Increase the height
        
        focus_options_frame = Frame(focus_frame)
        focus_options_frame.pack(fill="x", padx=5, pady=5)

        # Configure a 3-column grid with equal weights
        focus_options_frame.columnconfigure(0, weight=1)
        focus_options_frame.columnconfigure(1, weight=1)
        focus_options_frame.columnconfigure(2, weight=1)

        # Left button
        self.focus_btn = Button(focus_options_frame, text="Enable Auto Focus", command=self.toggle_auto_focus)
        self.focus_btn.grid(row=0, column=0, padx=5, pady=5, sticky="w")

        # Center checkbox
        self.hide_taskbar_btn = Checkbutton(focus_options_frame, text="Hide taskbar on focus",
                                              variable=self.hide_taskbar_var)
        self.hide_taskbar_btn.grid(row=0, column=1, padx=5, pady=5)

        # Right checkbox
        self.pause_alt_tab_var = BooleanVar(value=True)
        self.pause_alt_tab_btn = Checkbutton(focus_options_frame, text="Pause on Alt+Tab",
                                               variable=self.pause_alt_tab_var, command=self.toggle_pause_alt_tab)
        self.pause_alt_tab_btn.grid(row=0, column=2, padx=5, pady=5, sticky="e")
        
        # Log Frame
        log_frame = LabelFrame(self.root, text="Log")
        log_frame.configure(height=100)
        log_frame.pack(fill="both", expand=True, padx=10, pady=10)

        log_options_frame = Frame(log_frame)
        log_options_frame.pack(fill="x", padx=5, pady=2, anchor="w")

        self.logging_checkbox = Checkbutton(log_options_frame, text="Enable Logging",
                                                variable=self.logging_enabled, command=self.toggle_logging)
        self.logging_checkbox.pack(side=LEFT, padx=5)

        self.log_text = Text(log_frame, height=6, width=40, state="disabled")
        self.log_text.pack(fill="both", expand=True, padx=5, pady=5)

        scrollbar = Scrollbar(self.log_text, command=self.log_text.yview)
        scrollbar.pack(side=RIGHT, fill=Y)
        self.log_text.config(yscrollcommand=scrollbar.set)

        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        snap_settings_frame = Frame(self.window_mgmt_frame)
        snap_settings_frame.pack(fill="x", padx=5, pady=2, before=self.viz_canvas)
        
        Checkbutton(snap_settings_frame, text="Grid Snap", variable=self.grid_snap_enabled).pack(side=LEFT, padx=2)
        Label(snap_settings_frame, text="Grid Size:").pack(side=LEFT, padx=20)
        Spinbox(snap_settings_frame, from_=5, to=50, width=3, textvariable=self.grid_snap_size).pack(side=LEFT, padx=2)
        #ttk.Checkbutton(snap_settings_frame, text="Snap to Windows", variable=self.window_snap_enabled).pack(side=LEFT, padx=5)
        #ttk.Checkbutton(snap_settings_frame, text="Snap to Corners", variable=self.corner_snap_enabled).pack(side=LEFT, padx=5)
        
    def sanitize_keys(self, keys_string):
        # Split input by commas
        raw_keys = [k.strip() for k in keys_string.split(',')]
        valid_keys = []
        
        # Define allowable keys
        allowed_single_chars = set("abcdefghijklmnopqrstuvwxyz0123456789")
        allowed_special_keys = {
            'space', 'tab', 'enter', 'shift', 'alt', 'ctrl',
            'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12'
        }
        
        # Validate each key
        for key in raw_keys:
            if (len(key) == 1 and key.lower() in allowed_single_chars) or key.lower() in allowed_special_keys:
                valid_keys.append(key.lower())
        
        return ','.join(valid_keys)
        
    def on_keys_entry_focus_out(self, event):
        # Sanitize the keys first
        sanitized_keys = self.sanitize_keys(self.keys_entry.get())
        self.keys_entry.delete(0, END)
        self.keys_entry.insert(0, sanitized_keys)
        self.keys = sanitized_keys
        
        if self.is_broadcasting and not self.broadcast_all_keys.get():
            # Restart broadcasting with sanitized keys
            self.is_broadcasting = False
            self.toggle_broadcasting()
            self.log("Broadcasting restarted with updated keys")
        
    def setup_window_management_frame(self):
        app_width = self.root.winfo_width()
        app_height = self.root.winfo_height()
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        aspect_ratio = screen_width / screen_height
        frame_width = app_width - 40
        frame_height = int(frame_width / aspect_ratio)
        self.window_mgmt_frame.config(width=frame_width, height=frame_height)
        self.viz_canvas.config(height=frame_height)
        self.viz_canvas.bind("<Button-1>", self.start_window_drag)
        self.viz_canvas.bind("<B1-Motion>", self.drag_window)
        self.viz_canvas.bind("<ButtonRelease-1>", self.end_window_drag)
        self.viz_canvas.bind("<Button-3>", self.start_window_resize)
        self.viz_canvas.bind("<B3-Motion>", self.resize_window)
        self.viz_canvas.bind("<ButtonRelease-3>", self.end_window_resize)
        self.viz_canvas.bind("<Button-1>", self.start_window_resize, add="+")
        self.viz_canvas.bind("<B1-Motion>", self.resize_window, add="+")
        self.viz_canvas.bind("<ButtonRelease-1>", self.end_window_resize, add="+")

    def update_window_visualization(self):
        self.viz_canvas.delete("all")
        self.window_rects = {}
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        canvas_width = self.viz_canvas.winfo_width()
        canvas_height = self.viz_canvas.winfo_height()

        self.screen_scale = min(canvas_width / screen_width, canvas_height / screen_height)

        self.viz_canvas.create_rectangle(
            0, 0,
            screen_width * self.screen_scale,
            screen_height * self.screen_scale,
            outline="white", width=2
        )

        target_windows = self.get_target_windows()
        colors = ["red", "green", "blue", "yellow", "cyan", "magenta", "orange", "purple", "brown", "pink"]

        # Sort windows by their top-left corner position (upper left to clockwise)
        target_windows.sort(key=lambda w: (w.top, w.left))

        for i, window in enumerate(target_windows):
            color = colors[i % len(colors)]
            x1 = window.left * self.screen_scale
            y1 = window.top * self.screen_scale
            x2 = window.right * self.screen_scale
            y2 = window.bottom * self.screen_scale
            rect_id = self.viz_canvas.create_rectangle(
                x1, y1, x2, y2,
                fill=color, outline="white", width=1,
                tags=f"window_{i}"
            )

            # Add window number in top-left corner
            self.viz_canvas.create_text(
                x1 + 10, y1 + 10,
                text=f"#{i+1}",
                fill="white",
                font=("Arial", 10, "bold"),
                tags=f"window_{i}"
            )

            # Add window title in center
            title = window.title if len(window.title) < 20 else window.title[:17] + "..."
            self.viz_canvas.create_text(
                (x1 + x2) / 2, (y1 + y2) / 2,
                text=title, fill="white", font=("Arial", 8),
                tags=f"window_{i}"
            )

            resize_handle = self.viz_canvas.create_polygon(
                x2, y2 - 10, x2 - 10, y2, x2, y2,
                fill="white", outline="black", width=1,
                tags=f"resize_{i}"
            )

            self.window_rects[rect_id] = {
                "window": window,
                "index": i,
                "original_geometry": (window.left, window.top, window.right, window.bottom),
                "resize_handle": resize_handle
            }

        if not target_windows:
            self.viz_canvas.create_text(
                canvas_width / 2, canvas_height / 2,
                text="No windows selected", fill="white", font=("Arial", 12)
            )

    def start_window_drag(self, event):
        closest = self.viz_canvas.find_closest(event.x, event.y)
        if closest and closest[0] in self.window_rects:
            self.dragging_window = {
                "id": closest[0],
                "start_x": event.x,
                "start_y": event.y,
                "original_coords": self.viz_canvas.coords(closest[0]),
                "canvas_width": self.viz_canvas.winfo_width(),
                "canvas_height": self.viz_canvas.winfo_height()
            }
            self.viz_canvas.itemconfig(closest[0], width=2)

            # Hide the name, number, and resize handle
            window_info = self.window_rects[closest[0]]
            for item in self.viz_canvas.find_withtag(f"window_{window_info['index']}"):
                if "text" in self.viz_canvas.type(item):
                    self.viz_canvas.itemconfig(item, state="hidden")

            # Hide the resize handle
            resize_handle = window_info.get("resize_handle")
            if resize_handle:
                self.viz_canvas.itemconfig(resize_handle, state="hidden")

    def drag_window(self, event):
        if not self.dragging_window:
            return

        dx = event.x - self.dragging_window["start_x"]
        dy = event.y - self.dragging_window["start_y"]
        orig = self.dragging_window["original_coords"]

        # Calculate new coordinates
        new_x1 = orig[0] + dx
        new_y1 = orig[1] + dy
        new_x2 = orig[2] + dx
        new_y2 = orig[3] + dy

        # Apply snapping if enabled
        if self.grid_snap_enabled.get():
            snap_size = self.grid_snap_size.get() * self.screen_scale
            # Snap to grid
            new_x1 = round(new_x1 / snap_size) * snap_size
            new_y1 = round(new_y1 / snap_size) * snap_size
            new_x2 = new_x1 + (orig[2] - orig[0])
            new_y2 = new_y1 + (orig[3] - orig[1])

        # Snap to corners if enabled
        if self.corner_snap_enabled.get():
            canvas_width = self.dragging_window["canvas_width"]
            canvas_height = self.dragging_window["canvas_height"]
            corner_snap_distance = 20 * self.screen_scale

            # Top-left corner
            if abs(new_x1) < corner_snap_distance and abs(new_y1) < corner_snap_distance:
                new_x1 = 0
                new_y1 = 0
                new_x2 = orig[2] - orig[0]
                new_y2 = orig[3] - orig[1]

            # Top-right corner
            if abs(new_x2 - canvas_width) < corner_snap_distance and abs(new_y1) < corner_snap_distance:
                new_x2 = canvas_width
                new_y1 = 0
                new_x1 = new_x2 - (orig[2] - orig[0])
                new_y2 = orig[3] - orig[1]

            # Bottom-left corner
            if abs(new_x1) < corner_snap_distance and abs(new_y2 - canvas_height) < corner_snap_distance:
                new_x1 = 0
                new_y2 = canvas_height
                new_x2 = orig[2] - orig[0]
                new_y1 = new_y2 - (orig[3] - orig[1])

            # Bottom-right corner
            if abs(new_x2 - canvas_width) < corner_snap_distance and abs(new_y2 - canvas_height) < corner_snap_distance:
                new_x2 = canvas_width
                new_y2 = canvas_height
                new_x1 = new_x2 - (orig[2] - orig[0])
                new_y1 = new_y2 - (orig[3] - orig[1])

        # Snap to other windows if enabled
        if self.window_snap_enabled.get():
            snap_distance = 10 * self.screen_scale
            current_id = self.dragging_window["id"]

            for rect_id, info in self.window_rects.items():
                if rect_id == current_id:
                    continue

                rect_coords = self.viz_canvas.coords(rect_id)
                rx1, ry1, rx2, ry2 = rect_coords

                # Snap left edge to other window's right edge
                if abs(new_x1 - rx2) < snap_distance:
                    new_x1 = rx2
                    new_x2 = new_x1 + (orig[2] - orig[0])

                # Snap right edge to other window's left edge
                if abs(new_x2 - rx1) < snap_distance:
                    new_x2 = rx1
                    new_x1 = new_x2 - (orig[2] - orig[0])

                # Snap top edge to other window's bottom edge
                if abs(new_y1 - ry2) < snap_distance:
                    new_y1 = ry2
                    new_y2 = new_y1 + (orig[3] - orig[1])

                # Snap bottom edge to other window's top edge
                if abs(new_y2 - ry1) < snap_distance:
                    new_y2 = ry1
                    new_y1 = new_y2 - (orig[3] - orig[1])

        # Update the window position
        self.viz_canvas.coords(self.dragging_window["id"], new_x1, new_y1, new_x2, new_y2)

        # Update any child elements
        window_info = self.window_rects[self.dragging_window["id"]]
        for item in self.viz_canvas.find_withtag(f"window_{window_info['index']}"):
            if item != self.dragging_window["id"]:
                self.viz_canvas.move(item, new_x1 - orig[0], new_y1 - orig[1])
            
    def end_window_drag(self, event):
        if not self.dragging_window:
            return
        rect_id = self.dragging_window["id"]
        window_info = self.window_rects[rect_id]
        window = window_info["window"]
        new_coords = self.viz_canvas.coords(rect_id)
        new_left = int(new_coords[0] / self.screen_scale)
        new_top = int(new_coords[1] / self.screen_scale)
        new_right = int(new_coords[2] / self.screen_scale)
        new_bottom = int(new_coords[3] / self.screen_scale)
        width = new_right - new_left
        height = new_bottom - new_top
        try:
            window.moveTo(new_left, new_top)
            window.resizeTo(width, height)
            self.log(f"Moved window '{window.title}' to ({new_left}, {new_top}) with size {width}x{height}")
        except Exception as e:
            self.log(f"Error moving window: {str(e)}")
        self.viz_canvas.itemconfig(rect_id, width=1)

        # Show the name, number, and resize handle
        for item in self.viz_canvas.find_withtag(f"window_{window_info['index']}"):
            if "text" in self.viz_canvas.type(item):
                self.viz_canvas.itemconfig(item, state="normal")

        # Show the resize handle
        resize_handle = window_info.get("resize_handle")
        if resize_handle:
            self.viz_canvas.itemconfig(resize_handle, state="normal")

        self.dragging_window = None
        self.update_window_visualization()

    def start_window_resize(self, event):
        closest = self.viz_canvas.find_closest(event.x, event.y)
        if not closest:  # Check if closest is empty
            return  # No item found, so do nothing

        item_id = closest[0]  # Get the item ID
        tags = self.viz_canvas.gettags(item_id)

        if not tags:  # Check if tags is empty
            return  # No tags, so do nothing

        if "resize" in tags[0]:
            try:
                index = int(tags[0].split("_")[1])
                rect_id = None
                for rid, info in self.window_rects.items():
                    if info["index"] == index:
                        rect_id = rid
                        break

                if rect_id:
                    self.resizing_window = {
                        "id": rect_id,
                        "start_x": event.x,
                        "start_y": event.y,
                        "original_coords": self.viz_canvas.coords(rect_id)
                    }
                    self.viz_canvas.itemconfig(rect_id, width=2)
            except (ValueError, IndexError) as e:
                print(f"Error processing resize tag: {e}")
        pass
        
    def resize_window(self, event):
        if not self.resizing_window:
            return
            
        dx = event.x - self.resizing_window["start_x"]
        dy = event.y - self.resizing_window["start_y"]
        orig = self.resizing_window["original_coords"]
        
        # Calculate new coordinates
        new_x1 = orig[0]
        new_y1 = orig[1]
        new_x2 = orig[2] + dx
        new_y2 = orig[3] + dy
        
        # Apply snapping if enabled
        if self.grid_snap_enabled.get():
            snap_size = self.grid_snap_size.get() * self.screen_scale
            # Snap to grid
            new_x2 = round(new_x2 / snap_size) * snap_size
            new_y2 = round(new_y2 / snap_size) * snap_size
        
        # Snap to corners if enabled
        if self.corner_snap_enabled.get():
            canvas_width = self.viz_canvas.winfo_width()
            canvas_height = self.viz_canvas.winfo_height()
            corner_snap_distance = 20 * self.screen_scale
            
            # Bottom-right corner
            if abs(new_x2 - canvas_width) < corner_snap_distance and abs(new_y2 - canvas_height) < corner_snap_distance:
                new_x2 = canvas_width
                new_y2 = canvas_height
        
        # Snap to other windows if enabled
        if self.window_snap_enabled.get():
            snap_distance = 10 * self.screen_scale
            current_id = self.resizing_window["id"]
            
            for rect_id, info in self.window_rects.items():
                if rect_id == current_id:
                    continue
                    
                rect_coords = self.viz_canvas.coords(rect_id)
                rx1, ry1, rx2, ry2 = rect_coords
                
                # Snap right edge to other window's left edge
                if abs(new_x2 - rx1) < snap_distance:
                    new_x2 = rx1
                
                # Snap bottom edge to other window's top edge
                if abs(new_y2 - ry1) < snap_distance:
                    new_y2 = ry1
        
        # Update the window size
        self.viz_canvas.coords(self.resizing_window["id"], new_x1, new_y1, new_x2, new_y2)
        
        # Update any child elements
        window_info = self.window_rects[self.resizing_window["id"]]
        
        # Update resize handle position
        resize_handle = None
        for item in self.viz_canvas.find_withtag(f"resize_{window_info['index']}"):
            resize_handle = item
            break
            
        if resize_handle:
            self.viz_canvas.coords(resize_handle, 
                new_x2, new_y2 - 10, 
                new_x2 - 10, new_y2, 
                new_x2, new_y2)
                
        # Update window text position
        for item in self.viz_canvas.find_withtag(f"window_{window_info['index']}"):
            if item != self.resizing_window["id"] and "text" in self.viz_canvas.type(item):
                self.viz_canvas.coords(item, (new_x1 + new_x2) / 2, (new_y1 + new_y2) / 2)

    def end_window_resize(self, event):
        if not self.resizing_window:
            return
        rect_id = self.resizing_window["id"]
        window_info = self.window_rects[rect_id]
        window = window_info["window"]
        new_coords = self.viz_canvas.coords(rect_id)
        new_left = int(new_coords[0] / self.screen_scale)
        new_top = int(new_coords[1] / self.screen_scale)
        new_right = int(new_coords[2] / self.screen_scale)
        new_bottom = int(new_coords[3] / self.screen_scale)
        width = new_right - new_left
        height = new_bottom - new_top
        try:
            window.moveTo(new_left, new_top)
            window.resizeTo(width, height)
        except Exception as e:
            print(f"Error resizing window: {str(e)}")  # Debug print
        self.viz_canvas.itemconfig(rect_id, width=1)
        self.resizing_window = None
        self.update_window_visualization()


    def toggle_borderless(self):
        target_windows = self.get_target_windows()
        borderless = self.borderless_var.get()
        for window in target_windows:
            try:
                hwnd = window._hWnd
                style = win32gui.GetWindowLong(hwnd, win32con.GWL_STYLE)
                if borderless:
                    new_style = style & ~(win32con.WS_CAPTION | win32con.WS_THICKFRAME)
                    win32gui.SetWindowLong(hwnd, win32con.GWL_STYLE, new_style)
                else:
                    new_style = style | win32con.WS_CAPTION | win32con.WS_THICKFRAME
                    win32gui.SetWindowLong(hwnd, win32con.GWL_STYLE, new_style)
                win32gui.SetWindowPos(hwnd, 0, 0, 0, 0, 0,
                   win32con.SWP_NOMOVE | win32con.SWP_NOSIZE |
                   win32con.SWP_NOZORDER | win32con.SWP_FRAMECHANGED)
            except Exception as e:
                self.log(f"Error toggling borderless mode: {str(e)}")
        mode = "borderless" if borderless else "normal"
        self.log(f"Set {len(target_windows)} windows to {mode} mode")

    def auto_layout(self, aspect_ratio):
        target_windows = self.get_target_windows()
        if not target_windows:
            self.log("No windows to layout")
            return
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        window_count = len(target_windows)
        if aspect_ratio == "1:1":
            cols = int(window_count ** 0.5)
            if cols * cols < window_count:
                cols += 1
            rows = (window_count + cols - 1) // cols
            cell_width = screen_width // cols
            cell_height = screen_height // rows
            cell_width = cell_height = min(cell_width, cell_height)
        elif aspect_ratio == "16:9":
            if window_count <= 3:
                rows = 1
                cols = window_count
            else:
                rows = 2
                cols = (window_count + 1) // 2
            
            # Calculate cell dimensions
            cell_width = screen_width // cols
            cell_height = screen_height // rows
            
            # Adjust to maintain 16:9 aspect ratio
            if cell_width / cell_height > 16/9:
                cell_width = int(cell_height * 16/9)
            else:
                cell_height = int(cell_width * 9/16)
            
            # Calculate padding to center windows
            padding_x = (screen_width - (cols * cell_width)) // 2
            padding_y = (screen_height - (rows * cell_height)) // 2
            
            # Position windows
            for i, window in enumerate(target_windows):
                row = i // cols
                col = i % cols
                x = padding_x + (col * cell_width)
                y = padding_y + (row * cell_height)
                try:
                    window.moveTo(x, y)
                    window.resizeTo(cell_width, cell_height)
                except Exception as e:
                    self.log(f"Error arranging window: {str(e)}")         
        elif aspect_ratio == "21:9":
            cols = int((window_count * 21 / 9) ** 0.5)
            if cols == 0:
                cols = 1
            rows = (window_count + cols - 1) // cols
            cell_width = screen_width // cols
            cell_height = int(cell_width * 9 / 21)
        else:
            self.log(f"Unknown aspect ratio: {aspect_ratio}")
            return
        for i, window in enumerate(target_windows):
            row = i // cols
            col = i % cols
            x = col * cell_width
            y = row * cell_height
            try:
                window.moveTo(x, y)
                window.resizeTo(cell_width, cell_height)
            except Exception as e:
                self.log(f"Error arranging window: {str(e)}")
        self.log(f"Arranged {window_count} windows in {rows}x{cols} grid ({aspect_ratio})")
        self.update_window_visualization()

    def auto_fill(self):
        target_windows = self.get_target_windows()
        if not target_windows:
            self.log("No windows to layout")
            return
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        window_count = len(target_windows)
        cols = int(window_count ** 0.5)
        if cols * cols < window_count:
            cols += 1
        rows = (window_count + cols - 1) // cols
        cell_width = screen_width // cols
        cell_height = screen_height // rows
        for i, window in enumerate(target_windows):
            row = i // cols
            col = i % cols
            x = col * cell_width
            y = row * cell_height
            try:
                window.moveTo(x, y)
                window.resizeTo(cell_width, cell_height)
            except Exception as e:
                self.log(f"Error arranging window: {str(e)}")
        self.log(f"Arranged {window_count} windows to fill the screen")
        self.update_window_visualization()

    def toggle_logging(self):
        if self.logging_enabled.get():
            self.log("Logging enabled")
        else:
            self.log("Logging disabled")
        self.save_profile_settings()

    def toggle_broadcast_mode(self):
        if self.broadcast_all_keys.get():
            self.keys_entry.config(state="disabled")
            self.load_btn.config(state="disabled")
            self.save_btn.config(state="disabled")
            self.broadcast_select.config(state="disabled")
            self.broadcast_select_keys.set(False)
            self.broadcast_btn.config(state="normal")  # Enable broadcast button
        elif self.broadcast_select_keys.get():
            self.broadcast_all_keys.set(False)
            self.broadcast_all.config(state="disabled")
            self.broadcast_btn.config(state="normal")  # Enable broadcast button
        else:
            self.keys_entry.config(state="normal")
            self.load_btn.config(state="normal")
            self.save_btn.config(state="normal")
            self.broadcast_select.config(state="normal")
            self.broadcast_all.config(state="normal")
            self.broadcast_btn.config(state="disabled")  # Disable broadcast button
            
        self.save_profile_settings()
        
    def load_keys_from_file(self):
        self.load_keys()
        self.keys_entry.delete(0, END)
        self.keys_entry.insert(0, self.keys)
        self.log(f"Keys loaded from {self.get_profile_keys_file(self.current_profile)}")

    def log(self, message):
        if not self.logging_enabled.get():
            return
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_message = f"[{timestamp}] {message}"
        self.log_text.config(state="normal")
        self.log_text.insert(END, f"{log_message}\n")
        self.log_text.see(END)
        self.log_text.config(state="disabled")
        with open(self.log_file, "a") as f:
            f.write(f"{log_message}\n")

    def on_window_selected(self, event):
        target_windows = self.get_target_windows()
        self.log(f"Found {len(target_windows)} matching windows for '{self.target_window_pattern.get()}'")
        self.save_profile_settings()
        self.update_window_visualization()

    def refresh_window_list(self, event=None):
        self.window_list = self.get_all_windows()
        self.window_combo['values'] = self.window_list
        self.log(f"Refreshed window list, found {len(self.window_list)} windows")
        if self.target_window_pattern.get():
            target_windows = self.get_target_windows()
            self.log(f"Found {len(target_windows)} matching windows for '{self.target_window_pattern.get()}'")
            self.update_window_visualization()

    def toggle_broadcasting(self):
        if not self.is_broadcasting:
            if not self.target_window_pattern.get():
                return
            self.is_broadcasting = True
            self.broadcast_btn.config(text="Stop Broadcasting")
            target_windows = self.get_target_windows()
            mode_text = "all keyboard input" if self.broadcast_all_keys.get() else "selected keys"
            self.log(f"Starting broadcast ({mode_text}) to {len(target_windows)} windows matching '{self.target_window_pattern.get()}'")
            self.broadcast_thread = threading.Thread(target=self.broadcast_keys)
            self.broadcast_thread.daemon = True
            self.broadcast_thread.start()
        else:
            self.is_broadcasting = False
            self.broadcast_btn.config(text="Start Broadcasting")
            self.log("Broadcasting stopped")
        self.save_profile_settings()

    def toggle_auto_focus(self):
        if not self.is_auto_focusing:
            if not self.target_window_pattern.get():
                return
            self.is_auto_focusing = True
            self.focus_btn.config(text="Disable Auto Focus")
            target_windows = self.get_target_windows()
            self.log(f"Auto focus enabled for {len(target_windows)} windows matching '{self.target_window_pattern.get()}'")
            self.focus_thread = threading.Thread(target=self.auto_focus)
            self.focus_thread.daemon = True
            self.focus_thread.start()
        else:
            self.is_auto_focusing = False
            self.focus_btn.config(text="Enable Auto Focus")
            self.log("Auto focus disabled")
        self.save_profile_settings()

    def toggle_pause_alt_tab(self):
        if self.pause_alt_tab_var.get():
            self.log("Pause on Alt+Tab enabled")
            self.alt_tab_pressed = True
        else:
            self.log("Pause on Alt+Tab disabled")
            self.alt_tab_pressed = False

    def get_target_windows(self):
        pattern = self.target_window_pattern.get()
        target_windows = []
        if pattern:
            for window in gw.getAllWindows():
                try:
                    if window.title and pattern == window.title:
                        target_windows.append(window)
                except:
                    pass
        return target_windows

    def broadcast_keys(self):
        if self.broadcast_all_keys.get():
            self.broadcast_all_keyboard()
        else:
            self.broadcast_selected_keys()

    def broadcast_selected_keys(self):
        prev_key_states = {}
        key_hold_times = {}
        key_repeat_delay = 0.5  # Initial delay before repeating in seconds
        key_repeat_rate = 0.03  # Repeat rate in seconds
        
        while self.is_broadcasting and self.running:
            keys = [k.strip() for k in self.sanitize_keys(self.keys_entry.get()).split(',')]
            current_time = time.time()
            
            # Initialize tracking for new keys
            for key in keys:
                if key not in prev_key_states:
                    prev_key_states[key] = False
                    key_hold_times[key] = 0
            
            try:
                target_windows = self.get_target_windows()
                active_window = gw.getActiveWindow()
                
                if target_windows and any(window == active_window for window in target_windows):
                    for key in keys:
                        current_state = keyboard.is_pressed(key)
                        
                        if current_state:  # Key is pressed
                            if not prev_key_states[key]:  # First press
                                for window in target_windows:
                                    if window != active_window:
                                        win32api.PostMessage(window._hWnd, self.WM_KEYDOWN, 
                                                           ord(key.upper()) if len(key) == 1 else self.get_vk_code(key), 0)
                                key_hold_times[key] = current_time
                            elif current_time - key_hold_times[key] > key_repeat_delay:
                                # After delay, send key repeatedly
                                for window in target_windows:
                                    if window != active_window:
                                        win32api.PostMessage(window._hWnd, self.WM_KEYDOWN, 
                                                           ord(key.upper()) if len(key) == 1 else self.get_vk_code(key), 0)
                                key_hold_times[key] += key_repeat_rate  # Schedule next repeat
                        
                        prev_key_states[key] = current_state
            except Exception as e:
                self.log(f"Error: {str(e)}")
            time.sleep(0.01)
    def broadcast_all_keyboard(self):
        all_keys = [
            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'space', 'tab', 'enter', 'shift', 'alt', 'ctrl',
            'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12',
        ]
        prev_key_states = {key: False for key in all_keys}
        key_hold_times = {key: 0 for key in all_keys}
        key_repeat_delay = 0.5  # Initial delay before repeating in seconds
        key_repeat_rate = 0.03  # Repeat rate in seconds
        
        while self.is_broadcasting and self.running:
            try:
                target_windows = self.get_target_windows()
                active_window = gw.getActiveWindow()
                current_time = time.time()
                
                if target_windows and any(window == active_window for window in target_windows):
                    for key in all_keys:
                        current_state = keyboard.is_pressed(key)
                        vk_code = self.get_vk_code(key)
                        
                        if current_state and vk_code:  # Key is pressed
                            if not prev_key_states[key]:  # First press
                                for window in target_windows:
                                    if window != active_window:
                                        win32api.PostMessage(window._hWnd, self.WM_KEYDOWN, vk_code, 0)
                                key_hold_times[key] = current_time
                            elif current_time - key_hold_times[key] > key_repeat_delay:
                                # After delay, send key repeatedly
                                for window in target_windows:
                                    if window != active_window:
                                        win32api.PostMessage(window._hWnd, self.WM_KEYDOWN, vk_code, 0)
                                key_hold_times[key] += key_repeat_rate  # Schedule next repeat
                        
                        prev_key_states[key] = current_state
            except Exception as e:
                self.log(f"Error: {str(e)}")
            time.sleep(0.01)
        
    def get_vk_code(self, key):
        special_keys = {
            'space': win32con.VK_SPACE,
            'tab': win32con.VK_TAB,
            'enter': win32con.VK_RETURN,
            'shift': win32con.VK_SHIFT,
            'alt': win32con.VK_MENU,
            'ctrl': win32con.VK_CONTROL,
            'f1': win32con.VK_F1,
            'f2': win32con.VK_F2,
            'f3': win32con.VK_F3,
            'f4': win32con.VK_F4,
            'f5': win32con.VK_F5,
            'f6': win32con.VK_F6,
            'f7': win32con.VK_F7,
            'f8': win32con.VK_F8,
            'f9': win32con.VK_F9,
            'f10': win32con.VK_F10,
            'f11': win32con.VK_F11,
            'f12': win32con.VK_F12,
        }
        
        if key in special_keys:
            return special_keys[key]
        elif len(key) == 1:
            return ord(key.upper())
        elif key.isdigit():
            return ord(key)
        return 0

    def is_window_at_top(self, window, x, y):
        hwnd = win32gui.WindowFromPoint((x, y))
        if hwnd:
            rect = win32gui.GetWindowRect(hwnd)
            try:
                if window._hWnd == hwnd:
                    return True
            except:
                pass
        return False

    def auto_focus(self):
        last_focused_window = None
        
        while self.is_auto_focusing and self.running:
            if self.is_auto_focusing_paused:
                time.sleep(0.1)
                continue
            try:
                mouse_x, mouse_y = pyautogui.position()
                target_windows = self.get_target_windows()
                current_window = gw.getActiveWindow()
                
                # Check if we're still focusing on a target window
                current_is_target = any(window == current_window for window in target_windows)
                
                # If we moved from a target window to a non-target window, show taskbar
                if last_focused_window and not current_is_target and self.hide_taskbar_var.get():
                    self.toggle_taskbar(hide=False)
                
                for window in target_windows:
                    if (window.left <= mouse_x <= window.right and
                        window.top <= mouse_y <= window.bottom):
                        if window != current_window and self.is_window_at_top(window, mouse_x, mouse_y):
                            hwnd = window._hWnd
                            foreground_hwnd = ctypes.windll.user32.GetForegroundWindow()
                            foreground_thread = win32process.GetWindowThreadProcessId(foreground_hwnd)[0]
                            current_thread = win32api.GetCurrentThreadId()
                            try:
                                ctypes.windll.user32.AttachThreadInput(current_thread, foreground_thread, True)
                                win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL)
                                win32gui.SetWindowPos(hwnd, win32con.HWND_TOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)
                                win32gui.SetWindowPos(hwnd, win32con.HWND_NOTOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)
                                ctypes.windll.user32.SetForegroundWindow(hwnd)
                                ctypes.windll.user32.AttachThreadInput(current_thread, foreground_thread, False)
                                if ctypes.windll.user32.GetForegroundWindow() == hwnd:
                                    self.log(f"Focus changed to: {window.title}")
                                    last_focused_window = window
                                    
                                    # Hide taskbar if the option is enabled
                                    if self.hide_taskbar_var.get():
                                        self.toggle_taskbar(hide=True)
                                    
                                    break
                            except Exception as e:
                                self.log(f"Error details: {type(e).__name__}: {str(e)}")
                                try:
                                    ctypes.windll.user32.AttachThreadInput(current_thread, foreground_thread, False)
                                except:
                                    pass
                                try:
                                    win32gui.SendMessage(hwnd, win32con.WM_SYSCOMMAND, win32con.SC_RESTORE, 0)
                                    win32gui.SendMessage(hwnd, win32con.WM_ACTIVATE, win32con.WA_ACTIVE, 0)
                                except:
                                    pass
                                break
            except Exception as e:
                self.log(f"Error: {type(e).__name__}: {str(e)}")
            time.sleep(0.05)
        
    def on_closing(self):
        # Show taskbar if it was hidden
        if self.taskbar_hidden:
            self.toggle_taskbar(hide=False)
            
        self.save_profile_settings()
        self.running = False
        self.is_broadcasting = False
        self.is_auto_focusing = False
        if self.broadcast_thread and self.broadcast_thread.is_alive():
            self.broadcast_thread.join(1)
        if self.focus_thread and self.focus_thread.is_alive():
            self.focus_thread.join(1)
        self.root.destroy()

if __name__ == "__main__":
    root = Tk()
    app = AutoKeyBroadcaster(root)
    root.mainloop()
